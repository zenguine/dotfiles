" Vim Configuration Settings
" Initialization {{{
set nocompatible
set rtp+=~/.vim/vundle/
" Seems necessary for ultisnips to do filetype detection correctly
filetype off
call vundle#rc()

" let Vundle manage Vundle
" required! 
Bundle 'gmarik/vundle'

set t_Co=256 " seems important in order to get 256 color support or something..

"}}}
" Vundle Plugin List {{{

Bundle 'marijnh/tern_for_vim'
Bundle 'jelera/vim-javascript-syntax'
Bundle 'tristen/vim-sparkup.git'
Bundle 'gmarik/github-search.vim.git'
Bundle 'lukerandall/haskellmode-vim.git'
Bundle 'vim-scripts/haskell.vim'
Bundle 'majutsushi/tagbar.git'
Bundle 'sjl/gundo.vim.git'
Bundle 'tpope/vim-surround.git'
Bundle 'vim-scripts/bufkill.vim.git'
Bundle 'benmills/vimux.git'
Bundle 'duff/vim-scratch.git'
Bundle 'edsono/vim-matchit.git'
Bundle 'mileszs/ack.vim.git'
Bundle 'scrooloose/syntastic.git'
Bundle 'tpope/vim-commentary.git'
Bundle 'tpope/vim-fugitive.git'
Bundle 'tpope/vim-rails.git'
Bundle 'tpope/vim-repeat.git'
Bundle 'tmhedberg/SimpylFold.git'
Bundle 'pangloss/vim-javascript'
Bundle 'tpope/vim-unimpaired'
Bundle 'teramako/jscomplete-vim.git'
Bundle 'vim-scripts/mako.vim--Torborg.git'
Bundle 'vim-scripts/mako.vim.git'
Bundle 'altercation/vim-colors-solarized.git'
Bundle 'vim-scripts/python.vim'
Bundle 'vim-scripts/indenthaskell.vim'
Bundle 'vim-scripts/TaskList.vim'
Bundle 'jimenezrick/vimerl.git'
Bundle 'nathanaelkane/vim-indent-guides.git'
Bundle 'vim-scripts/vimwiki.git'
Bundle 'vim-scripts/VOoM.git'
Bundle 'tpope/vim-markdown'
Bundle 'vim-scripts/tlib.git'
Bundle 'hsitz/VimOrganizer.git'
Bundle 'derekwyatt/vim-scala'
Bundle 'vim-scripts/AutoTag'

" New plugins for testing
Bundle 'Shougo/unite.vim'
Bundle 'Valloric/YouCompleteMe'
Bundle 'h1mesuke/unite-outline'
Bundle 'Shougo/vimproc.vim'
Bundle 'SirVer/ultisnips'
Bundle 'thinca/vim-ref'

"}}}
" Basic Settings {{{
"set terminal title and stifle shell messages
set title           
set shortmess=atI 
set viminfo='100,f1
set autoindent
set autoread " automatically update open buffers when change externally.
set cmdheight=1
" Strewth, what a mess. Copied from the vim docs, if memory serves.
set comments=s:/*,mb:**,ex:*/,://,b:#,b:##,:%,:XCOMM,n:>,fb:-
set ignorecase
set formatoptions=orc
set history=1000
set wildignore+=*.swp,*.bak,*.pyc,*.class,*.hi,*.o
set visualbell
set noerrorbells
set nobackup
set noswapfile
set hlsearch
set incsearch
set keywordprg=
set mouse=a
set mousehide
set mousemodel=popup_setpos
set nowrapscan
set wrap
set linebreak
set formatoptions+=l
set nolist
set path=.,/usr/include,/usr/local/include
set smartcase
set nosmartindent
set smarttab
set tabstop=2
set shiftwidth=4
set expandtab
set showmode
set viminfo='50,\"10000,n~/.viminfo
set wildchar=9
set wildmode=longest,list,full
set wildmenu
set nocompatible
set hidden
set splitright
set splitbelow
set number
set virtualedit=all
set lazyredraw
set showcmd
set tildeop " tilde behaves as an operator
let mapleader = ','
syntax on
filetype plugin indent on

set scrolloff=3
"}}}
" General mappings {{{

nnoremap ; :
vnoremap ; :

nnoremap + <C-a>
nnoremap - <C-x>
" if you forget to sudo..
cmap w!! %!sudo tee > /dev/null %

"execute current line with bash and output result
noremap ,ye "vyy:r!<C-r>v<Backspace><CR>

" Fix wrapped line behavior
nnoremap j gj
nnoremap k gk

vnoremap < <gv
vnoremap > >gv
" Insert mode - map jk to <Esc>
imap jk <Esc>

" Mappings to edit important files quickly {{{
nmap <leader>ev :e ~/.vimrc<CR>
nmap <leader>ez :e ~/.zshrc<CR>
nmap <leader>eg :e ~/.gvimrc<CR>
nmap <leader>et :e ~/.tmux.conf<CR>
nmap <leader>ex :e ~/.xmonad/xmonad.hs<CR>
nmap <leader>es :e ~/.dotfiles/scripts.linkme/startup.sh<CR>
nmap <leader>s :source ~/.vimrc<CR>:source ~/.gvimrc<CR>
"}}}
"
" Make "Y" behavior consistent with 'D','C', etc.
nmap Y y$

" Create Blank Newlines and stay in Normal mode
nnoremap <silent> zn o<Esc>
nnoremap <silent> zp O<Esc>

" double percentage sign in command mode is expanded to directory of current file 
cnoremap %% <C-R>=expand('%:h').'/'<cr>

" ,, switches between most recently viewed buffers
nnoremap <leader><space> <C-^>

" Emacs bindings in command line mode
cnoremap <c-a> <home>
cnoremap <c-e> <end>

" 'Splint line' - converse to J (join lines)
nnoremap S i<cr><esc><right>

" Dont insert space between joined lines with J, gJ for that behavior
nnoremap J Jx
nnoremap gJ J

"}}}
" Line Numbering {{{

" Function to toggle relative vs absolute line numbering
function! ToggleNumbering()
    if exists("+relativenumber")
        if &relativenumber
            set number
        else
            set relativenumber
        endif
    else
        set number!
    endif
endfunc

"}}}
" Plugin settings {{{
" Easymotion settings {{{
let g:EasyMotion_leader_key = '<leader><leader>'
"}}}
" YouCompleteMe settings {{{

let g:ycm_complete_in_comments_and_strings=1
let g:ycm_key_list_select_completion=['<C-n>', '<Down>']
let g:ycm_key_list_previous_completion=['<C-p>', '<Up>']
let g:ycm_filetype_blacklist={'unite': 1}

"}}}
" Unite settings {{{
"
nnoremap [unite] <Nop>
nmap <space> [unite]

if executable('ack')
    let g:unite_source_grep_command='ack'
    let g:unite_source_grep_default_opts='--no-heading --no-color -a'
    let g:unite_source_grep_recursive_opt=''
endif

let g:unite_source_history_yank_enable = 1
call unite#filters#matcher_default#use(['matcher_fuzzy'])
call unite#filters#sorter_default#use(['sorter_rank'])
call unite#set_profile('files', 'smartcase', 1)
call unite#custom#source('line,outline,file,file_rec,file_rec/async','matchers','matcher_fuzzy')

let g:unite_data_directory='~/.vim/.cache/unite'
let g:unite_enable_start_insert=1
let g:unite_source_history_yank_enable=1
let g:unite_source_rec_max_cache_files=5000
let g:unite_prompt='Â» '

nnoremap <silent> [unite]<space> :<C-u>Unite -toggle -no-split -buffer-name=mixed file_rec/async buffer file_mru bookmark<cr>
nnoremap <silent> [unite]f :<C-u>Unite -toggle -no-split -buffer-name=files   -start-insert file_rec/async<cr>
nnoremap <silent> <C-p> :<C-u>Unite -toggle -no-split -buffer-name=files   -start-insert file_rec/async<cr>
nnoremap <silent> [unite]m :<C-u>Unite -toggle -no-split -buffer-name=mru     -start-insert file_mru<cr>
nnoremap <silent> [unite]o :<C-u>Unite -no-split -buffer-name=outline outline<cr>
nnoremap <silent> [unite]y :<C-u>Unite -toggle -buffer-name=yanks    history/yank<cr>
nnoremap <silent> [unite]b :<C-u>Unite -no-split -buffer-name=buffer  buffer<cr>
nnoremap <silent> [unite]s :<C-u>Unite -quick-match -no-split -buffer-name=buffer  buffer<cr>
nnoremap <silent> [unite]l :<C-u>Unite -auto-resize -start-insert -buffer-name=line line<cr> 
nnoremap <silent> [unite]/ :<C-u>Unite -no-quit -buffer-name=search grep:.<cr>
nnoremap <silent> [unite]re :<C-u>Unite ref/erlang -no-split -buffer-name=erlang_docs -start-insert -horizontal<CR>
nnoremap <silent> [unite]rp :<C-u>Unite ref/pydoc -no-split -buffer-name=python_docs -start-insert -horizontal<CR>

" Custom mappings for the unite buffer
autocmd FileType unite call s:unite_settings()
function! s:unite_settings()
  " Play nice with supertab
  let b:SuperTabDisabled=1
  " Enable navigation with control-j and control-k in insert mode
  imap <buffer> <C-j>   <Plug>(unite_select_next_line)
  imap <buffer> <C-k>   <Plug>(unite_select_previous_line)
endfunction

" }}}
" Vim-Ref settings {{{

let g:ref_use_vimproc = 1
let g:ref_open = 'vsplit'
let g:ref_cache_dir = expand('~/.vim/tmp/ref_cache/')

" }}}
" Vim-powerline settings {{{
let g:Powerline_symbols='unicode'
let g:Powerline_stl_path_style='filename'
let g:Powerline_colorscheme='default'

" Enable line below if you want the whitespace marker
" call Pl#Theme#InsertSegment('ws_marker', 'after', 'lineinfo')

set laststatus=2

set encoding=utf-8
set fillchars+=stl:\ ,stlnc:\
"}}}
" NerdTree Settings {{{
" Enable easy NERDTree toggling
nnoremap <silent> <leader>n :NERDTreeToggle<CR>
"}}}
" taglist and ctags configuration {{{
" let Tlist_Ctags_Cmd = "/usr/bin/ctags"
" let Tlist_WinWidth = 50
map <silent> <leader>q :TagbarToggle<cr>
" map <F8> :!/usr/bin/ctags -R --python-kinds=-i --c++-kinds=+p --fields=+iaS --extra=+q %%<CR>
map <F8> :!ctags -R .<cr><CR>
" uses ghci to generate haskell tags file recursively from cwd
map <F9> :!echo ":ctags" \| ghci **/*.hs<CR>
map <F10> :!pytags.py %%/**/*.py<CR>
map <A-]> :vsp <CR>:exec("tag ".expand("<cword>"))<CR>
"}}}
" Gundo and Undo Settings {{{

set undolevels=1000 "maximum number of changes that can be undone
map <silent> <leader>u :GundoToggle<CR>

" Persistent undo
if exists("+undofile")
    " undofile - This allows you to use undos after exiting and restarting
    " This, like swap and backups, uses .vim-undo first, then ~/.vim/undo
    " :help undo-persistence
    " This is only present in 7.3+
    if isdirectory($HOME . '/.vim/undo') == 0
        :silent !mkdir -p ~/.vim/undo > /dev/null 2>&1
    endif
    set undodir=./.vim-undo//
    set undodir+=~/.vim/undo//
    set undofile
endif
"}}}
" CtrlP Settings {{{
let g:ctrlp_map = '<c-p>'
let g:ctrlp_match_window_reversed = 1
let g:ctrlp_open_multiple_files = '2vr'
let g:ctrlp_extensions = ['tag','buffertag']
let g:ctrlp_match_window_bottom = 0

" Non-standard part of ctrlp: Specify a filtering regular expression.
" Regexp must be specified in extended regexp compatible form
let g:ctrlp_ignore = '\.pyc$|\.o$|\.hi$|\.swp$'
let g:ctrlp_user_command = ['.git/', "cd %s && git ls-files . -co --exclude-standard | grep -vE '" . g:ctrlp_ignore . "'"]

let g:path_to_matcher = "~/bin/matcher"

let g:ctrlp_match_func = { 'match': 'GoodMatch' }

function! GoodMatch(items, str, limit, mmode, ispath, crfile, regex)"{{{

    " Create a cache file if not yet exists
    let cachefile = ctrlp#utils#cachedir().'/matcher.cache'
    if !( filereadable(cachefile) && a:items == readfile(cachefile) )
        call writefile(a:items, cachefile)
    endif
    if !filereadable(cachefile)
        return []
    endif

    " a:mmode is currently ignored. In the future, we should probably do
    " something about that. the matcher behaves like "full-line".
    let cmd = g:path_to_matcher.' --limit '.a:limit.' --manifest '.cachefile.' '
    if !( exists('g:ctrlp_dotfiles') && g:ctrlp_dotfiles )
        let cmd = cmd.'--no-dotfiles '
    endif
    let cmd = cmd.a:str

    return split(system(cmd), "\n")

endfunction
"}}}
"}}}
" Haskell-mode settings {{{
let g:haddock_browser = "/usr/bin/firefox"
let g:ghc = "/usr/bin/ghc"
"}}}
" Python-mode settings {{{u
let g:pymode_run_key = '<leader>pr'
let g:pymode_breakpoint_key = '<leader>pb'
let g:pymode_lint = 0
"}}}
" Ultisnips settings {{{
let g:UltiSnipsSnippetDirectories = ["bundle/ultisnips/UltiSnips"]
let g:UltiSnipsExpandTrigger="<tab>"
let g:UltiSnips="<tab>"
let g:UltiSnipsJumpForwardTrigger="<tab>"
let g:UltiSnipsJumpBackwardTrigger="<s-tab>"
"}}}
" Supertab and auto-complete {{{
let g:SuperTabDefaultCompletionType = "context"
set completeopt=menuone,longest,preview
let g:SuperTabContextDefaultCompletionType = "<c-n>"
" Completion remappings
inoremap <c-f> <c-x><c-f>
inoremap <c-l> <c-x><c-l>
"}}}
" Sparkup settings {{{
"let g:sparkupExecuteMapping = '<c-b>'
let g:sparkupNextMapping = '<c-f>'
let g:sparkupPreviousMapping = '<c-b>'
"}}}
" Fugitive "{{{
autocmd FileType gitcommit DiffGitCached | wincmd L | wincmd p

nnoremap <leader>gd :Gdiff<cr>
nnoremap <leader>gs :Gstatus<cr>
nnoremap <leader>gw :Gwrite<cr>
nnoremap <leader>ga :Gadd<cr>
nnoremap <leader>gb :Gblame<cr>
nnoremap <leader>gco :Gcheckout<cr>
nnoremap <leader>gci :Gcommit<cr>
nnoremap <leader>gm :Gmove<cr>
nnoremap <leader>gr :Gremove<cr>
nnoremap <leader>gl :Shell git gl -18<cr>:wincmd \|<cr>
"}}}
" Scratch"{{{
command! ScratchToggle call ScratchToggle()

nnoremap <silent> <leader><tab> :ScratchToggle<cr>

function! ScratchToggle() "
    if exists("w:is_scratch_window")
        unlet w:is_scratch_window
        exec "q"
    else
        exec "normal! :Sscratch\<cr>\<C-W>J:resize 13\<cr>"
        let w:is_scratch_window = 1
    endif
endfunction
"}}}
" Vimux Settings {{{
let VimuxHeight = "30"

" Run command with current filename as final argument
map <silent> <leader>rb :call RunVimTmuxCommand(input("Command? ") . " " . bufname("%"))<CR>

" Prompt for a command to run
map <silent> <leader>rp :PromptVimTmuxCommand<CR>

" Run last command executed by RunVimTmuxCommand
map <silent> <leader>rl :RunLastVimTmuxCommand<CR>

" Inspect runner pane
map <silent> <leader>ri :InspectVimTmuxRunner<CR>

" Close all other tmux panes in current window
map <silent> <leader>rx :CloseVimTmuxPanes<CR>

" Interrupt any command running in the runner pane
map <silent> <leader>rs :InterruptVimTmuxRunner<CR>

" If text is selected, save it in the v buffer and send that buffer it to tmux
vmap <silent> <leader>rr "vy :call RunVimTmuxCommand(@v . "\n", 0)<CR>

" Select current paragraph and send it to tmux
nmap <silent> <leader>rr vip<leader>rr<CR>

" Select current paragraph and send it to tmux
nmap <silent> <leader>rf ggVG<leader>rr<CR>

" A fix related to the version of ruby vim was compiled with
ruby << EOF
class Object
def flush; end unless Object.new.respond_to?(:flush)
end
EOF
"}}}
" Neocomplcache Settings {{{

" " Disable AutoComplPop.
" let g:acp_enableAtStartup = 0
" " Use neocomplcache.
" let g:neocomplcache_enable_at_startup = 1
" " Use smartcase.
" let g:neocomplcache_enable_smart_case = 1
" " Use camel case completion.
" let g:neocomplcache_enable_camel_case_completion = 1
" " Use underbar completion.
" let g:neocomplcache_enable_underbar_completion = 1
" " Set minimum syntax keyword length.
" let g:neocomplcache_min_syntax_length = 3
" let g:neocomplcache_lock_buffer_name_pattern = '\*ku\*'

" " Define dictionary.
" let g:neocomplcache_dictionary_filetype_lists = {
"     \ 'default' : '',
"     \ 'vimshell' : $HOME.'/.vimshell_hist',
"     \ 'scheme' : $HOME.'/.gosh_completions'
"     \ }

" " Define keyword.
" if !exists('g:neocomplcache_keyword_patterns')
"   let g:neocomplcache_keyword_patterns = {}
" endif
" let g:neocomplcache_keyword_patterns['default'] = '\h\w*'

" " Plugin key-mappings.
" imap <C-k>     <Plug>(neocomplcache_snippets_expand)
" smap <C-k>     <Plug>(neocomplcache_snippets_expand)
" inoremap <expr><C-g>     neocomplcache#undo_completion()
" inoremap <expr><C-l>     neocomplcache#complete_common_string()

" " SuperTab like snippets behavior.
" imap <expr><TAB> neocomplcache#sources#snippets_complete#expandable() ? "\<Plug>(neocomplcache_snippets_expand)" : pumvisible() ? "\<C-n>" : "\<TAB>"

" " Recommended key-mappings.
" " <CR>: close popup and save indent.
" inoremap <expr><CR>  neocomplcache#smart_close_popup() . "\<CR>"
" " <TAB>: completion.
" " inoremap <expr><TAB>  pumvisible() ? "\<C-n>" : "\<TAB>"
" " <C-h>, <BS>: close popup and delete backword char.
" inoremap <expr><C-h> neocomplcache#smart_close_popup()."\<C-h>"
" inoremap <expr><BS> neocomplcache#smart_close_popup()."\<C-h>"
" inoremap <expr><C-y>  neocomplcache#close_popup()
" inoremap <expr><C-e>  neocomplcache#cancel_popup()

" " AutoComplPop like behavior.
" let g:neocomplcache_enable_auto_select = 0

" " Enable omni completion.
" autocmd FileType css setlocal omnifunc=csscomplete#CompleteCSS
" autocmd FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
" autocmd FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
" autocmd FileType python setlocal omnifunc=pythoncomplete#Complete
"
" autocmd FileType xml setlocal omnifunc=xmlcomplete#CompleteTags

" Enable heavy omni completion.
" if !exists('g:neocomplcache_omni_patterns')
"   let g:neocomplcache_omni_patterns = {}
" endif
" let g:neocomplcache_omni_patterns.ruby = '[^. *\t]\.\w*\|\h\w*::'
" " autocmd FileType ruby setlocal omnifunc=rubycomplete#Complete
" let g:neocomplcache_omni_patterns.php = '[^. \t]->\h\w*\|\h\w*::'
" let g:neocomplcache_omni_patterns.c = '\%(\.\|->\)\h\w*'
" let g:neocomplcache_omni_patterns.cpp = '\h\w*\%(\.\|->\)\h\w*\|\h\w*::'

"}}}
" Indent Guides {{{
set ts=4 sw=4 et
let g:indent_guides_start_level = 2
let g:indent_guides_guide_size = 1
" }}}
" Search and movement {{{

" Sane regex syntax
noremap / /\v
noremap ? ?\v

" Open a Quickfix window for the last search.
nnoremap <silent> <leader>? :execute 'vimgrep /'.@/.'/g %'<CR>:copen<CR>

" Autocenter some movement commands
noremap n nzz
noremap N Nzz
" Spacebar removes search highlighting
nnoremap <silent> <leader>h :nohl<CR>

" Dont jump on * or #
nnoremap * *''
nnoremap # #''

noremap ' `
noremap ` '

nnoremap <C-e> 3<C-e>
nnoremap <C-y> 3<C-y>

" Tab to switch between matching braces
map <Tab> %

" Easier to type
noremap H ^
noremap L g_

"}}}

" Vimwiki settings {{{
let g:vimwiki_list = [{'path': '~/vimwiki/',
            \ 'auto_export' : 1,
            \ 'template_path' : '~/vimwikihtml/templates/',
            \ 'template_default' : 'def_template',
            \ 'template_ext' : '.html',
            \ 'path_html': '~/vimwikihtml'}]
" }}}
" }}}
" Window Navigation {{{

" Window navigation quick shortcuts
nnoremap <leader>wd <C-w>c
nnoremap <silent> <leader>wo :on<CR>

" No arrow keys allowed - Remapped to resize windows
nmap <left>  3<c-w><
nmap <right> 3<c-w>>
nmap <up>    3<c-w>+
nmap <down>  3<c-w>-
imap <left>  <c-o><left>
imap <right> <c-o><right>
imap <up>    <c-o><up>
imap <down>  <c-o><down>

" First attempt at maximize window functionality
let g:win_maxed_mode = 0
function! ToggleWinMax()
    if g:win_maxed_mode
        wincmd =
        let g:win_maxed_mode = 0
    else
        call MaximizeWindow()
        let g:win_maxed_mode = 1
    endif
endfunction

function! MaximizeWindow()
    resize +500
    vertical resize +500
endfunction

" <leader>z (zoom) to max, unmax window
nnoremap <silent> <leader>z :call ToggleWinMax()<CR>

" Better window navigation
" C-[hjkl] moves to neighboring window or if it doesn't exist then it
" creates it.

function! WinMove(key, blank) 
    let t:curwin = winnr()
    exec "wincmd ".a:key
    if (t:curwin == winnr()) "we havent moved
        if a:key == 'k' " going up
            if a:blank == 1
                leftabove new
            else
                leftabove split
            endif
        elseif a:key == 'j' " going down
            if a:blank == 1
                rightbelow new
            else
                rightbelow split
            endif
        elseif a:key == 'h' " going left
            if a:blank == 1
                leftabove vnew
            else
                leftabove vnew
            endif
        elseif a:key == 'l' " going right
            if a:blank == 1
                rightbelow vnew
            else
                rightbelow vsplit
            endif
        endif
        exec "wincmd ".a:key
    else " We have moved and if in max mode stay there
        if g:win_maxed_mode
            call MaximizeWindow()
        endif
    endif
endfunction

" if exists('$TMUX')
"     function! TmuxOrSplitSwitch(wincmd, tmuxdir)
"         let previous_winnr = winnr()
"         silent! execute "wincmd " . a:wincmd
"         if previous_winnr == winnr()
"             call system("tmux select-pane -" . a:tmuxdir)
"             redraw!
"         endif
"     endfunction

"     let previous_title = substitute(system("tmux display-message -p '#{pane_title}'"), '\n', '', '')
"     let &t_ti = "\<Esc>]2;vim\<Esc>\\" . &t_ti
"     let &t_te = "\<Esc>]2;". previous_title . "\<Esc>\\" . &t_te

"     nnoremap <silent> <C-h> :call TmuxOrSplitSwitch('h', 'L')<cr>
"     nnoremap <silent> <C-j> :call TmuxOrSplitSwitch('j', 'D')<cr>
"     nnoremap <silent> <C-k> :call TmuxOrSplitSwitch('k', 'U')<cr>
"     nnoremap <silent> <C-l> :call TmuxOrSplitSwitch('l', 'R')<cr>
" else
    nnoremap <silent> <C-h> :call WinMove('h',0)<CR>
    nnoremap <silent> <C-j> :call WinMove('j',0)<CR>
    nnoremap <silent> <C-@> :call WinMove('j',0)<CR>
    nnoremap <silent> <C-k> :call WinMove('k',0)<CR>
    nnoremap <silent> <C-l> :call WinMove('l',0)<CR>
" endif

" Highlight cursor line only in active window
set cursorline
au WinEnter * setlocal cursorline
au WinLeave * setlocal nocursorline


"}}}
" Filetype Specific Settings {{{

" Fixing some filetype detection {{{
au BufRead *tmux*conf* set filetype=tmux
au BufRead *xsession* set filetype=sh
au BufRead *Xdefaults* set filetype=xdefaults
au BufRead *Xmodmap* set filetype=xmodmap
au BufRead *pentadactylrc* set filetype=vim
"}}}

" Haskell {{{
let g:haddock_indexfiledir = "~/.dotfiles/vim.linkme"
let g:haddock_browser = "/usr/bin/firefox"
let g:ghc = "/usr/bin/ghc"

augroup ft_haskell
    autocmd!
    au BufEnter *.hs compiler ghc
    autocmd FileType haskell setlocal formatoptions+=t
    autocmd FileType haskell let b:ghc_staticoptions = '-Wall -Werror'
augroup END


" " From Good Haskell Style http://urchin.earth.li/~ian/style/haskell.html
" setlocal expandtab
" setlocal tabstop=8
" setlocal shiftwidth=8
" setlocal textwidth=79


" "}}}
" PDF {{{
augroup ft_pdf
    " use vim to read pdf files text
    autocmd!
    autocmd BufReadPre *.pdf set ro nowrap
    autocmd BufReadPost *.pdf silent %!pdftotext "%" -nopgbrk -layout -q -eol unix -
    autocmd BufWritePost *.pdf silent !rm -rf ~/PDF/%
    autocmd BufWritePost *.pdf silent !lp -s -d pdffg "%"
    autocmd BufWritePost *.pdf silent !until [ -e ~/PDF/% ]; do sleep 1; done
    autocmd BufWritePost *.pdf silent !mv ~/PDF/% %:p:h
augroup end
"}}}
" Vim {{{
augroup ft_vim
    autocmd!
    au FileType vim setlocal foldmethod=marker
    au FileType vim setlocal formatoptions-=t
    au FileType vim normal! zM
augroup end
"}}}
" Python {{{
augroup ft_python
    autocmd!
    au FileType python setl omnifunc=pythoncomplete#Complete

    let g:not_in_cmdwin = 1
    " Next two lines make the python pydoc window auto close with omnicomplete
    autocmd CursorMovedI * if (pumvisible() == 0 && g:not_in_cmdwin) |pclose|endif
    autocmd InsertLeave * if (pumvisible() == 0 && g:not_in_cmdwin) |pclose|endif
    " autocmd BufWritePost * :!ctags -R .

    " Open python files with folds already closed
    " au FileType python normal! zM
augroup END

augroup cmdwin_hack
    autocmd!
    autocmd CmdwinEnter * let g:not_in_cmdwin = 0
    autocmd CmdwinLeave * let g:not_in_cmdwin = 1
augroup END
"}}}
" Javascript {{{
function! JavaScriptFold() " {{{
    setl foldmethod=syntax
    setl foldlevelstart=1
    syn region foldBraces start=/{/ end=/}/ transparent fold keepend extend

    function! FoldText()
        return substitute(getline(v:foldstart), '{.*', '{...}', '')
    endfunction
    setl foldtext=MyFoldText()
endfunction"}}}
augroup ft_javascript
    autocmd!
    au FileType javascript call JavaScriptFold()
    au FileType javascript setl fen
    " au FileType javascript normal! zM
augroup end
"}}}
" Mako {{{
augroup ft_mako
    au!
    au BufEnter *.mako setl filetype=mako
augroup END
"}}}
"}}}
" Color Scheme {{{

" For tomorrow night colorscheme
set background=dark
color solarized

"}}}
" Not being used (commented) {{{

" " Add python libraries to path so can use gf on module name to view
" " source
" python << EOF
" import os
" import sys
" import vim
" for p in sys.path:
"     if os.path.isdir(p):
"         vim.command(r"set path+=%s" % (p.replace(" ", r"\ ")))
" EOF

" "Move a line of text using ALT+[jk], (un)indent with ALT+[hl]
" nnoremap <silent> <A-j> :m+<CR>==
" nnoremap <silent> <A-k> :m-2<CR>==
" nnoremap <A-h> <<
" nnoremap <A-l> >>
" inoremap <A-j> <Esc>:m+<CR>==gi
" inoremap <A-k> <Esc>:m-2<CR>==gi
" inoremap <A-h> <Esc><<`]a
" inoremap <A-l> <Esc>>>`]a
" vnoremap <A-j> :m'>+<CR>gv=gv
" vnoremap <A-k> :m-2<CR>gv=gv
" vnoremap <A-h> <gv
" vnoremap <A-l> >gv

" " These are so we can use alt key mappings in a terminal without
" " eightBitInput i.e. urxvt
" set <A-h>=h
" set <A-j>=j
" set <A-k>=k
" set <A-l>=l
" set <A-]>=]

"}}}
" Refactoring Functions {{{
function! ExtractVariable()
    let name = input("Variable name: ")
    if name == ''
        return
    endif
    " Enter visual mode (not sure why this is needed since we're already in
    " visual mode anyway)
    normal! gv

    " Replace selected text with the variable name
    exec "normal! c" . name
    " Define the variable on the line above
    exec "normal! O" . name . " = "
    " Paste the original selected text to be the variable value
    normal! $p
endfunction

function! InlineVariable()
    " Copy the variable under the cursor into the 'a' register
    :let l:tmp_a = @a
    :normal! "ayiw
    " Delete variable and equals sign
    :normal! 2daW
    " Delete the expression into the 'b' register
    :let l:tmp_b = @b
    :normal! "bd$
    " Delete the remnants of the line
    :normal! dd
    " Go to the end of the previous line so we can start our search for the
    " usage of the variable to replace. Doing '0' instead of 'k$' doesn't
    " work; I'm not sure why.
    normal! k$
    " Find the next occurence of the variable
    exec '/\<' . @a . '\>'
    " Replace that occurence with the text we yanked
    exec ':.s/\<' . @a . '\>/' . @b
    :let @a = l:tmp_a
    :let @b = l:tmp_b
endfunction

nnoremap<leader>vi :call InlineVariable()<cr>
vnoremap <leader>ve :call ExtractVariable()<cr>
"}}}
" Folding {{{
set foldenable
set foldmethod=marker
set foldlevel=99
set foldopen-=block
set foldcolumn=0
" nnoremap <space> za
" vnoremap <space> za

" Make zO recursively open whatever top level fold we're in, no matter where the
" cursor happens to be.
nnoremap zO zCzO
nnoremap - za


function! MyFoldText() 
    let line = getline(v:foldstart)
    let nucolwidth = &fdc + &number * &numberwidth
    let windowwidth = winwidth(0) - nucolwidth - 3
    let foldedlinecount = v:foldend - v:foldstart
    " expand tabs into spaces
    let onetab = strpart(' ', 0, &tabstop)
    let line = substitute(line, '\t', onetab, 'g')
    let line = strpart(line, 0, windowwidth - 2 -len(foldedlinecount))
    let fillcharcount = windowwidth - len(line) - len(foldedlinecount)
    return line . 'â¦' . repeat(" ",fillcharcount) . foldedlinecount . 'â¦' . ' '
endfunction 

set foldtext=MyFoldText()
"}}}
" Status Line {{{
"Git branch
function! GitBranch()
    let branch = system("git branch 2> /dev/null | sed -e '/^[^*]/d' -e 's/* //'")
    if branch != ''
        return '   Git Branch: ' . substitute(branch, '\n', '', 'g')
    en
    return ''
endfunction

function! CurDir()
    return substitute(getcwd(), '/Users/amir/', "~/", "g")
endfunction

function! HasPaste()
    if &paste
        return 'PASTE MODE  '
    en
    return ''
endfunction

" Format the statusline
set statusline=\ %{HasPaste()}%F%m%r%h\ %w\ \ CWD:\ %r%{CurDir()}%h\ \ \ Line:\ %l/%L%{GitBranch()}
" }}}
