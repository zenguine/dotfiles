" Vim Configuration Settings
" Initialization {{{
set nocompatible
set rtp+=~/.vim/vundle/
call vundle#rc()

" let Vundle manage Vundle
" required! 
Bundle 'gmarik/vundle'

set t_Co=256 " seems important in order to get 256 color support or something..

"}}}
" Vundle Plugin List {{{
Bundle 'Lokaltog/vim-powerline.git'
Bundle 'gmarik/github-search.vim.git'
Bundle 'lukerandall/haskellmode-vim.git'
Bundle 'majutsushi/tagbar.git'
Bundle 'phenguin/ultisnips.git'
Bundle 'scrooloose/nerdtree.git'
Bundle 'sjl/gundo.vim.git'
Bundle 'tpope/vim-surround.git'
Bundle 'vim-scripts/bufkill.vim.git'
Bundle 'Lokaltog/vim-easymotion.git'
Bundle 'benmills/vimux.git'
Bundle 'duff/vim-scratch.git'
Bundle 'edsono/vim-matchit.git'
Bundle 'ervandew/supertab.git'
Bundle 'kien/ctrlp.vim.git'
Bundle 'mileszs/ack.vim.git'
Bundle 'scrooloose/syntastic.git'
Bundle 'tpope/vim-commentary.git'
Bundle 'tpope/vim-fugitive.git'
Bundle 'tpope/vim-rails.git'
Bundle 'tpope/vim-repeat.git'
Bundle 'vim-scripts/ruby-matchit.git'
Bundle 'tmhedberg/SimpylFold.git'
Bundle 'pangloss/vim-javascript'
Bundle 'javascript.vim'
Bundle 'tpope/vim-unimpaired'
Bundle 'vim-scripts/pythoncomplete.git'
Bundle 'teramako/jscomplete-vim.git'
Bundle 'vim-scripts/mako.vim--Torborg.git'
Bundle 'vim-scripts/mako.vim.git'

"}}}
" Basic Settings {{{
"set terminal title and stifle shell messages
set title           
set shortmess=atI 
set viminfo='100,f1
set autoindent
set autoread " automatically update open buffers when change externally.
set cmdheight=1
" Strewth, what a mess. Copied from the vim docs, if memory serves.
set comments=s:/*,mb:**,ex:*/,://,b:#,b:##,:%,:XCOMM,n:>,fb:-
set ignorecase
set formatoptions=orc
set history=1000
set wildignore+=*.swp,*.bak,*.pyc,*.class,*.hi,*.o
set visualbell
set noerrorbells
set nobackup
set noswapfile
set hlsearch
set incsearch
set keywordprg=
set mouse=a
set mousehide
set mousemodel=popup_setpos
set nowrapscan
set wrap
set linebreak
set formatoptions+=l
set nolist
set path=.,/usr/include,/usr/local/include
set smartcase
set nosmartindent
set smarttab
set tabstop=2
set shiftwidth=4
set expandtab
set showmode
set viminfo='50,\"10000,n~/.viminfo
set wildchar=9
set wildmode=longest,list,full
set wildmenu
set nocompatible
set hidden
set splitright
set splitbelow
set number
set virtualedit=all
set lazyredraw
set showcmd
set tildeop " tilde behaves as an operator
let mapleader = ','
syntax on
filetype plugin indent on

set scrolloff=3
"}}}
" General mappings {{{

nnoremap ; :
vnoremap ; :

nnoremap + <C-a>
nnoremap - <C-x>
" if you forget to sudo..
cmap w!! %!sudo tee > /dev/null %

"execute current line with bash and output result
noremap ,ye "vyy:r!<C-r>v<Backspace><CR>

" Fix wrapped line behavior
nnoremap j gj
nnoremap k gk

vnoremap < <gv
vnoremap > >gv
" Insert mode - map jk to <Esc>
imap jk <Esc>

" Mappings to edit important files quickly {{{
nmap <leader>ev :e ~/.dotfiles/vimrc.linkme<CR>
nmap <leader>ez :e ~/.dotfiles/zshrc.linkme<CR>
nmap <leader>eg :e ~/.dotfiles/gvimrc.linkme<CR>
nmap <leader>et :e ~/.dotfiles/tmux.conf.linkme<CR>
nmap <leader>ex :e ~/.dotfiles/xmonad.linkme/xmonad.hs<CR>
nmap <leader>es :e ~/.dotfiles/bin.linkme/startup.sh<CR>
nmap <leader>s :source ~/.vimrc<CR>:source ~/.gvimrc<CR>
"}}}
" Make "Y" behavior consistent with 'D','C', etc.
nmap Y y$

" Create Blank Newlines and stay in Normal mode
nnoremap <silent> zn o<Esc>
nnoremap <silent> zp O<Esc>

" double percentage sign in command mode is expanded to directory of current file 
cnoremap %% <C-R>=expand('%:h').'/'<cr>

" ,, switches between most recently viewed buffers
nnoremap <leader><space> <C-^>

" No arrow keys allowed - Remapped to resize windows
nmap <left>  3<c-w><
nmap <right> 3<c-w>>
nmap <up>    3<c-w>+
nmap <down>  3<c-w>-


" Emacs bindings in command line mode
cnoremap <c-a> <home>
cnoremap <c-e> <end>

" 'Splint line' - converse to J (join lines)
nnoremap S i<cr><esc><right>

" Dont insert space between joined lines with J, gJ for that behavior
nnoremap J Jx
nnoremap gJ J

"}}}
" Line Numbering {{{

" Function to toggle relative vs absolute line numbering
function! ToggleNumbering()
    if exists("+relativenumber")
        if &relativenumber
            set number
        else
            set relativenumber
        endif
    else
        set number!
    endif
endfunc

" leader-z to switch between rel/abs line numbering schemes
noremap <silent> <leader>z :call ToggleNumbering()<CR>
"}}}
" Plugin settings {{{
" Easymotion settings {{{
let g:EasyMotion_leader_key = '<leader><leader>'
"}}}
" Vim-powerline settings {{{
let g:Powerline_symbols='fancy'

" Enable line below if you want the whitespace marker
" call Pl#Theme#InsertSegment('ws_marker', 'after', 'lineinfo')

set laststatus=2

set encoding=utf-8
set fillchars+=stl:\ ,stlnc:\
"}}}
" NerdTree Settings {{{
" Enable easy NERDTree toggling
nnoremap <silent> <leader>n :NERDTreeToggle<CR>
"}}}
" taglist and ctags configuration {{{
" let Tlist_Ctags_Cmd = "/usr/bin/ctags"
" let Tlist_WinWidth = 50
map <silent> <leader>q :TagbarToggle<cr>
map <F8> :!/usr/bin/ctags -R --c++-kinds=+p --fields=+iaS --extra=+q %%<CR>
" uses ghci to generate haskell tags file recursively from cwd
map <F9> :!echo ":ctags" \| ghci **/*.hs<CR>
map <F10> :!pytags.py %%/**/*.py<CR>
map <A-]> :vsp <CR>:exec("tag ".expand("<cword>"))<CR>
"}}}
" Gundo and Undo Settings {{{

set undolevels=1000 "maximum number of changes that can be undone
map <silent> <leader>u :GundoToggle<CR>

" Persistent undo
if exists("+undofile")
    " undofile - This allows you to use undos after exiting and restarting
    " This, like swap and backups, uses .vim-undo first, then ~/.vim/undo
    " :help undo-persistence
    " This is only present in 7.3+
    if isdirectory($HOME . '/.vim/undo') == 0
        :silent !mkdir -p ~/.vim/undo > /dev/null 2>&1
    endif
    set undodir=./.vim-undo//
    set undodir+=~/.vim/undo//
    set undofile
endif
"}}}
" CtrlP Settings {{{
let g:ctrlp_map = '<c-p>'
let g:ctrlp_match_window_reversed = 1
let g:ctrlp_open_multiple_files = '2vr'
let g:ctrlp_extensions = ['tag','buffertag']
let g:ctrlp_match_window_bottom = 0

" Non-standard part of ctrlp: Specify a filtering regular expression.
" Regexp must be specified in extended regexp compatible form
let g:ctrlp_ignore = '\.pyc$|\.o$|\.hi$|\.swp$'
let g:ctrlp_user_command = ['.git/', "cd %s && git ls-files . -co --exclude-standard | grep -vE '" . g:ctrlp_ignore . "'"]

let g:path_to_matcher = "~/bin/matcher"

let g:ctrlp_match_func = { 'match': 'GoodMatch' }

function! GoodMatch(items, str, limit, mmode, ispath, crfile, regex)"{{{

    " Create a cache file if not yet exists
    let cachefile = ctrlp#utils#cachedir().'/matcher.cache'
    if !( filereadable(cachefile) && a:items == readfile(cachefile) )
        call writefile(a:items, cachefile)
    endif
    if !filereadable(cachefile)
        return []
    endif

    " a:mmode is currently ignored. In the future, we should probably do
    " something about that. the matcher behaves like "full-line".
    let cmd = g:path_to_matcher.' --limit '.a:limit.' --manifest '.cachefile.' '
    if !( exists('g:ctrlp_dotfiles') && g:ctrlp_dotfiles )
        let cmd = cmd.'--no-dotfiles '
    endif
    let cmd = cmd.a:str

    return split(system(cmd), "\n")

endfunction
"}}}
"}}}
" Haskell-mode settings {{{
au BufEnter *.hs compiler ghc
let g:haddock_browser = "/usr/bin/firefox"
let g:ghc = "/usr/bin/ghc"
"}}}
" Ultisnips settings {{{
let g:UltiSnipsSnippetDirectories = ["bundle/ultisnips/UltiSnips"]
let g:UltiSnipsExpandTrigger="<tab>"
let g:UltiSnips="<tab>"
let g:UltiSnipsJumpForwardTrigger="<tab>"
let g:UltiSnipsJumpBackwardTrigger="<s-tab>"
"}}}
" Supertab and auto-complete {{{
let g:SuperTabDefaultCompletionType = "context"
set completeopt=menuone,longest,preview
let g:SuperTabContextDefaultCompletionType = "<c-n>"
" Completion remappings
inoremap <c-f> <c-x><c-f>
inoremap <c-l> <c-x><c-l>
"}}}
" Sparkup settings {{{
"let g:sparkupExecuteMapping = '<c-b>'
let g:sparkupNextMapping = '<c-f>'
let g:sparkupPreviousMapping = '<c-b>'
"}}}
" Ack-vim, quickfix, and location list settings {{{
" <leader>a to open up ack search
nmap <leader>a :call QFStateToggle()<cr>:Ack! -i 

" Quickfix and location list mappings
nmap ]q :cnext<CR>zvzz
nmap [q :cprevious<CR>zvzz

" Location list mappings primarily for syntastic
nmap ]l :lnext<CR>zvzz
nmap [l :lprevious<CR>zvzz

" Quickfix functionality toggling {{{
nmap <silent> <leader>tq :call QuickfixToggle()<cr>

let g:quickfix_is_open = 0

function! QFStateToggle()
    if g:quickfix_is_open
        let g:quickfix_is_open = 0
    else
        let g:quickfix_is_open = 1
    endif
endfunction

let g:quickfix_return_to_window = winnr()

function! QuickfixToggle()
    if g:quickfix_is_open
        cclose
        let g:quickfix_is_open = 0
        execute g:quickfix_return_to_window . "wincmd w"
    else
        let g:quickfix_return_to_window = winnr()
        copen
        let g:quickfix_is_open = 1
    endif
endfunction"}}}
" Location List toggling {{{
nmap <silent> <leader>tl :call LocationListToggle()<cr>

let g:locationlist_is_open = 0

function! LLStateToggle()
    if g:locationlist_is_open
        let g:locationlist_is_open = 0
    else
        let g:locationlist_is_open = 1
    endif
endfunction

let g:locationlist_return_to_window = winnr()

function! LocationListToggle()
    if g:locationlist_is_open
        lclose
        let g:locationlist_is_open = 0
        execute g:locationlist_return_to_window . "wincmd w"
    else
        let g:locationlist_return_to_window = winnr()
        lopen
        let g:locationlist_is_open = 1
    endif
endfunction"}}}

"}}}
" Fugitive "{{{
autocmd FileType gitcommit DiffGitCached | wincmd L | wincmd p

nnoremap <leader>gd :Gdiff<cr>
nnoremap <leader>gs :Gstatus<cr>
nnoremap <leader>gw :Gwrite<cr>
nnoremap <leader>ga :Gadd<cr>
nnoremap <leader>gb :Gblame<cr>
nnoremap <leader>gco :Gcheckout<cr>
nnoremap <leader>gci :Gcommit<cr>
nnoremap <leader>gm :Gmove<cr>
nnoremap <leader>gr :Gremove<cr>
nnoremap <leader>gl :Shell git gl -18<cr>:wincmd \|<cr>
"}}}
" Scratch"{{{
command! ScratchToggle call ScratchToggle()

nnoremap <silent> <leader><tab> :ScratchToggle<cr>

function! ScratchToggle() "
    if exists("w:is_scratch_window")
        unlet w:is_scratch_window
        exec "q"
    else
        exec "normal! :Sscratch\<cr>\<C-W>J:resize 13\<cr>"
        let w:is_scratch_window = 1
    endif
endfunction
"}}}
" Vimux Settings {{{
let VimuxHeight = "30"

" Run command with current filename as final argument
map <silent> <leader>rb :call RunVimTmuxCommand(input("Command? ") . " " . bufname("%"))<CR>

" Prompt for a command to run
map <silent> <leader>rp :PromptVimTmuxCommand<CR>

" Run last command executed by RunVimTmuxCommand
map <silent> <leader>rl :RunLastVimTmuxCommand<CR>

" Inspect runner pane
map <silent> <leader>ri :InspectVimTmuxRunner<CR>

" Close all other tmux panes in current window
map <silent> <leader>rx :CloseVimTmuxPanes<CR>

" Interrupt any command running in the runner pane
map <silent> <leader>rs :InterruptVimTmuxRunner<CR>

" If text is selected, save it in the v buffer and send that buffer it to tmux
vmap <silent> <leader>rr "vy :call RunVimTmuxCommand(@v . "\n", 0)<CR>

" Select current paragraph and send it to tmux
nmap <silent> <leader>rr vip<leader>rr<CR>

" Select current paragraph and send it to tmux
nmap <silent> <leader>rf ggVG<leader>rr<CR>

" A fix related to the version of ruby vim was compiled with
ruby << EOF
class Object
def flush; end unless Object.new.respond_to?(:flush)
end
EOF
"}}}
"}}}
" Search and movement {{{

" Sane regex syntax
noremap / /\v
noremap ? ?\v

" Open a Quickfix window for the last search.
nnoremap <silent> <leader>? :execute 'vimgrep /'.@/.'/g %'<CR>:copen<CR>

" Autocenter some movement commands
noremap n nzz
noremap N Nzz
" Spacebar removes search highlighting
nnoremap <silent> <leader>h :nohl<CR>

" Dont jump on * or #
nnoremap * *''
nnoremap # #''

noremap ' `
noremap ` '

nnoremap <C-e> 3<C-e>
nnoremap <C-y> 3<C-y>

" Tab to switch between matching braces
map <Tab> %

" Easier to type
noremap H ^
noremap L g_

"}}}
" Window Navigation {{{

" Window navigation quick shortcuts
nnoremap <leader>wd <C-w>c
nnoremap <silent> <leader>wo :on<CR>

" Better window navigation
" C-[hjkl] moves to neighboring window or if it doesn't exist then it
" creates it.

function! WinMove(key) 
    let t:curwin = winnr()
    exec "wincmd ".a:key
    if (t:curwin == winnr()) "we havent moved
        if a:key == 'k' " going up
            leftabove new
        elseif a:key == 'j' " going down
            rightbelow new
        elseif a:key == 'h' " going left
            leftabove vnew
        elseif a:key == 'l' " going right
            rightbelow vnew
        endif
        exec "wincmd ".a:key
    endif
endfunction

nnoremap <silent> <C-h> :call WinMove('h')<CR>
nnoremap <silent> <C-j> :call WinMove('j')<CR>
nnoremap <silent> <C-@> :call WinMove('j')<CR>
nnoremap <silent> <C-k> :call WinMove('k')<CR>
nnoremap <silent> <C-l> :call WinMove('l')<CR>

" Highlight cursor line only in active window
set cursorline
au WinEnter * setlocal cursorline
au WinLeave * setlocal nocursorline


"}}}
" Filetype Specific Settings {{{

" Fixing some filetype detection {{{
au BufRead *tmux*conf* set filetype=tmux
au BufRead *xsession* set filetype=sh
au BufRead *Xdefaults* set filetype=xdefaults
au BufRead *Xmodmap* set filetype=xmodmap
au BufRead *pentadactylrc* set filetype=vim
"}}}

" Haskell {{{
" augroup ft_haskell
"     autocmd!
"     au Bufenter *.hs compiler ghc
"     autocmd FileType haskell setlocal formatoptions+=t
"     autocmd FileType haskell let b:ghc_staticoptions = '-Wall -Werror'
" augroup END


" " From Good Haskell Style http://urchin.earth.li/~ian/style/haskell.html
" setlocal expandtab
" setlocal tabstop=8
" setlocal shiftwidth=8
" setlocal textwidth=79


" "}}}
" PDF {{{
augroup ft_pdf
    " use vim to read pdf files text
    autocmd!
    autocmd BufReadPre *.pdf set ro nowrap
    autocmd BufReadPost *.pdf silent %!pdftotext "%" -nopgbrk -layout -q -eol unix -
    autocmd BufWritePost *.pdf silent !rm -rf ~/PDF/%
    autocmd BufWritePost *.pdf silent !lp -s -d pdffg "%"
    autocmd BufWritePost *.pdf silent !until [ -e ~/PDF/% ]; do sleep 1; done
    autocmd BufWritePost *.pdf silent !mv ~/PDF/% %:p:h
augroup end
"}}}
" Vim {{{
augroup ft_vim
    autocmd!
    au FileType vim setlocal foldmethod=marker
    au FileType vim setlocal formatoptions-=t
    au FileType vim normal zM
augroup end
"}}}
" Python {{{
augroup ft_python
    autocmd!
    au FileType python setl omnifunc=pythoncomplete#Complete
    " Next two lines make the python pydoc window auto close with omnicomplete
    " autocmd CursorMovedI * if pumvisible() == 0|pclose|endif
    " autocmd InsertLeave * if pumvisible() == 0|pclose|endif

    " Open python files with folds already closed
    au FileType python normal zM
augroup END
"}}}
" Javascript {{{
function! JavaScriptFold() " {{{
    setl foldmethod=syntax
    setl foldlevelstart=1
    syn region foldBraces start=/{/ end=/}/ transparent fold keepend extend

    function! FoldText()
        return substitute(getline(v:foldstart), '{.*', '{...}', '')
    endfunction
    setl foldtext=MyFoldText()
endfunction"}}}
augroup ft_javascript
    autocmd!
    au FileType javascript call JavaScriptFold()
    au FileType javascript setl fen
    au FileType javascript normal zM
    au Filetype javascript setl omnifunc=javascriptcomplete#CompleteJS
augroup end
"}}}
" Mako {{{
augroup ft_mako
    au!
    au BufEnter *.mako setl filetype=mako
augroup END
"}}}
"}}}
" Color Scheme {{{
set background=dark
let g:solarized_termcolors=16
color solarized
"}}}
" Not being used (commented) {{{

" " Add python libraries to path so can use gf on module name to view
" " source
" python << EOF
" import os
" import sys
" import vim
" for p in sys.path:
"     if os.path.isdir(p):
"         vim.command(r"set path+=%s" % (p.replace(" ", r"\ ")))
" EOF

" "Move a line of text using ALT+[jk], (un)indent with ALT+[hl]
" nnoremap <silent> <A-j> :m+<CR>==
" nnoremap <silent> <A-k> :m-2<CR>==
" nnoremap <A-h> <<
" nnoremap <A-l> >>
" inoremap <A-j> <Esc>:m+<CR>==gi
" inoremap <A-k> <Esc>:m-2<CR>==gi
" inoremap <A-h> <Esc><<`]a
" inoremap <A-l> <Esc>>>`]a
" vnoremap <A-j> :m'>+<CR>gv=gv
" vnoremap <A-k> :m-2<CR>gv=gv
" vnoremap <A-h> <gv
" vnoremap <A-l> >gv

" " These are so we can use alt key mappings in a terminal without
" " eightBitInput i.e. urxvt
" set <A-h>=h
" set <A-j>=j
" set <A-k>=k
" set <A-l>=l
" set <A-]>=]

"}}}
" Refactoring Functions {{{
function! ExtractVariable()
    let name = input("Variable name: ")
    if name == ''
        return
    endif
    " Enter visual mode (not sure why this is needed since we're already in
    " visual mode anyway)
    normal! gv

    " Replace selected text with the variable name
    exec "normal c" . name
    " Define the variable on the line above
    exec "normal! O" . name . " = "
    " Paste the original selected text to be the variable value
    normal! $p
endfunction

function! InlineVariable()
    " Copy the variable under the cursor into the 'a' register
    :let l:tmp_a = @a
    :normal "ayiw
    " Delete variable and equals sign
    :normal 2daW
    " Delete the expression into the 'b' register
    :let l:tmp_b = @b
    :normal "bd$
    " Delete the remnants of the line
    :normal dd
    " Go to the end of the previous line so we can start our search for the
    " usage of the variable to replace. Doing '0' instead of 'k$' doesn't
    " work; I'm not sure why.
    normal k$
    " Find the next occurence of the variable
    exec '/\<' . @a . '\>'
    " Replace that occurence with the text we yanked
    exec ':.s/\<' . @a . '\>/' . @b
    :let @a = l:tmp_a
    :let @b = l:tmp_b
endfunction

nnoremap<leader>vi :call InlineVariable()<cr>
vnoremap <leader>ve :call ExtractVariable()<cr>
"}}}
" Folding {{{
set foldenable
set foldmethod=marker
set foldlevel=99
set foldopen-=block
set foldcolumn=1
nnoremap <space> za
" vnoremap <space> za

" Make zO recursively open whatever top level fold we're in, no matter where the
" cursor happens to be.
nnoremap zO zCzO


function! MyFoldText() 
    let line = getline(v:foldstart)
    let nucolwidth = &fdc + &number * &numberwidth
    let windowwidth = winwidth(0) - nucolwidth - 3
    let foldedlinecount = v:foldend - v:foldstart
    " expand tabs into spaces
    let onetab = strpart(' ', 0, &tabstop)
    let line = substitute(line, '\t', onetab, 'g')
    let line = strpart(line, 0, windowwidth - 2 -len(foldedlinecount))
    let fillcharcount = windowwidth - len(line) - len(foldedlinecount)
    return line . '…' . repeat(" ",fillcharcount) . foldedlinecount . '…' . ' '
endfunction 

set foldtext=MyFoldText()
"}}}
